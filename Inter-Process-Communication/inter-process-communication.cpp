/*
 Inter Process Communication (IPC)

    A process can be of two types:

    1. Independent process.
    2. Co-operating process.


    An independent process is not affected by the execution of other processes.
    An co-operating process is not affected by the execution of other processes.

    An independent process will execute very efficiently
    An co-operative nature can be utilized for increasing computational speed, convenience, and modularity.

    Inter-process communication (IPC) is a mechanism that allows processes to communicate with each other and synchronize their actions.

    The communication between these processes can be seen as a method of co-operation between them.
    Processes can communicate with each other through both:
        1. Shared Memory
        2. Message passing

    An operating system can implement both methods of communication.

        ** shared memory methods of communication **
    Communication between processes using shared memory requires processes to share some variable, and it completely depends on how the programmer will implement it.
    One way of communication using shared memory can be imagined like this:
    Suppose process1 and process2 are executing simultaneously, and they share some resources.
    Process1 generates information about certain computations or resources being used and keeps it as a record in shared memory.
    When process2 needs to use the shared information, it will check in the record stored in shared memory and take note of the information generated by process1 and act accordingly.
    Processes can use shared memory for extracting information as a record from another process as well as for delivering any specific information to other processes.


        ** shared memory Producer-Consumer problem  **
    There are two processes: Producer and Consumer.
    The producer produces some items and the Consumer consumes that item.
    The two processes share a common space or memory location known as a buffer
    where the item produced by the Producer is stored and from which the Consumer consumes the item if needed.

    There are two versions of this problem:
    Problem -1:
    The unbounded buffer problem in which the Producer can keep on producing items and there is no limit on the size of the buffer.
    Problem -2:
    The bounded buffer problem in which the Producer can produce up to a certain number of items before it starts waiting for Consumer to consume it.

    We will discuss the bounded buffer problem.
    1. The Producer and the Consumer will share some common memory.
    2. Then the producer will start producing items. If the total produced item is equal to the size of the buffer, the producer will wait to get it consumed by the Consumer. 3. Similarly, the consumer will first check for the availability of the item. If no item is available, the Consumer will wait for the Producer to produce it. If there are items available, Consumer will consume them.


        ** Messaging Passing methods of communication **
    In this method, processes communicate with each other without using any kind of shared memory. If two processes p1 and p2 want to communicate with each other, they proceed as follows:

    1. Establish a communication link.
        (if a link already exists, no need to establish it again.)
    2. Start exchanging messages using basic primitives.
    3. We need at least two primitives:
        – send(message, destination) or send(message)
        – receive(message, host) or receive(message)


    The message size can be of fixed size or of variable size.
    If fixed size message - easy to OS designer but complicated programmer
    If variable size message - complicated programmer but easy to OS designer.

    A standard message can have two parts: header part and body part.

    The header part is used for storing message type, destination id, source id, message length, and control information.

    The control information contains information like what to do if runs out of buffer space, sequence number, priority.

    Generally, message is sent using FIFO style.

    Message Passing through Communication Link.
    1. Direct and Indirect Communication link

    There are couple of methods of implementing communication links.
    While implementing the link, there are some questions that need to be kept in mind like :
        1. How are links established?
        2. Can a link be associated with more than two processes?
        3. How many links can there be between every pair of communicating processes?
        4. What is the capacity of a link?
        5. Is the size of a message that the link can accommodate fixed or variable?
        6. Is a link unidirectional or bi-directional?

    A link has some capacity that determines the number of messages that can reside in it temporarily for which every link has a queue associated with it.
    The queue capacity which can be of:
        1. zero capacity
        2. bounded capacity
        3. unbounded capacity.
    In zero capacity, the sender waits until the receiver informs the sender that it has received the message.
    In non-zero capacity cases, a process does not know whether a message has been received or not after the send operation. For this, the sender must communicate with the receiver explicitly.

    Implementation of the link depends on the situation:
        It can be direct communication link
        It can be in-directed communication link.

    Direct Communication links are implemented when the processes use a specific process identifier for communication, but it is hard to identify for the sender ahead of time.

    In-direct Communication is done via a shared mailbox (port), which consists of a queue of messages.
    The sender keeps the message in mailbox and the receiver picks them up.


    ** Message Passing through Exchanging the Messages. **

    Synchronous and Asynchronous Message Passing:

    A process that is blocked is one that is waiting for some event, such as a resource becoming available or the completion of an I/O operation.

    IPC is possible between the processes on same computer as well as on the processes running on different computer. i.e. in networked/distributed system.

    In both cases, the process may or may not be blocked while sending a message or  receiving a message so message passing may be blocking or non-blocking.

    Blocking OR Synchronous Message Passing :
    Blocking sender means: sender will be blocked until receiver receive the message.
    Blocking receive means: receive will be blocked until sender sends the message.

    Non-blocking OR A-Synchronous Message Passing :
    Non-blocking sender means: sender will be sending message continuously
    Non-blocking receive means: receiver will be receiving message continuously the valid message or null message.

    It is more natural for a sender it is more natural to be non-blocking after message passing as there may be a need to send the message to different processes.
    However, the sender expects acknowledgment from the receiver in case the send fails.

    It is more natural for a receiver to be blocking after issuing the receive as the information from the received message may be used for further execution.
    At the same time, if the message send keep on failing, the receiver will have to wait indefinitely.

    That is why we also consider the other possibility of message passing.
    There are basically three preferred combinations:
        1. Blocking send and blocking receive
        2. Non-blocking send and Non-blocking receive
        3. Non-blocking send and Blocking receive (Mostly used)

        ** Direct message passing **
    The process which wants to communicate must explicitly name the recipient or sender of the communication. e.g. send(p1, message) means send the message to p1.
    Similarly, receive(p2, message) means to receive the message from p2.

    In this method of communication, The link gets established automatically, which can be either unidirectional or bidirectional.
    But one link can be used between one pair of the sender and receiver and one pair of sender and receiver should not possess more than one pair of links.

    Symmetry and asymmetry between sending and receiving can also be implemented i.e. either both processes will name each other for sending and receiving the messages or only the sender will name the receiver for sending the message and there is no need for the receiver for naming the sender for receiving the message.

    The problem with this method of communication is that if the name of one process changes, this method will not work.

    In Indirect message passing, processes use mailboxes (also referred to as ports) for sending and receiving messages.
    Each mailbox has a unique id and processes can communicate only if they share a mailbox. Link established only if processes share a common mailbox and a single link can be associated with many processes.
    Each pair of processes can share several communication links and these links may be unidirectional or bi-directional.
    Suppose two processes want to communicate through Indirect message passing, the required operations are:
        1. Create a mailbox
        2. Use this mailbox for sending and receiving messages
        3. Then destroy the mailbox.

    The standard primitives used are:
        send(A, message)  - which means send the message to mailbox A.
        received (A, message) - which means send the message to mailbox A.

    There is a problem with this mailbox implementation.

    Suppose there are more than two processes sharing the same mailbox and suppose the process p1 sends a message to the mailbox, which process will be the receiver?

    This can be solved by either enforcing that only two processes can share a single mailbox or enforcing that only one process is allowed to execute the receive at a given time or select any process randomly and notify the sender about the receiver.

    A mailbox can be made private to a single sender/receiver pair and can also be shared between multiple sender/receiver pairs.
    Port is an implementation of such mailbox that can have multiple senders and a single receiver.
    It is used in client/server applications (in this case the server is the receiver). The port is owned by the receiving process and created by OS on the request of the receiver process and can be destroyed either on request of the same receiver processor when the receiver terminates itself.

    Enforcing that only one process is allowed to execute the receive can be done using the concept of mutual exclusion.
    Mutex mailbox is created which is shared by n process.
    The sender is non-blocking and sends the message.
    The first process which executes the receive will enter in the critical section and all other processes will be blocking and will wait.

    Producer-Consumer problem using the message passing concept. The producer places items (inside messages) in the mailbox and the consumer can consume an item when at least one message present in the mailbox.

    Examples of IPC systems
        Posix       : uses shared memory method.
        Mac         : uses message passing
        Windows XP  : uses message passing using local procedural calls

    Communication in client/server Architecture:
    There are various mechanism:
        Pipe
        Socket
        Remote Procedural calls (RPCs)

*/
